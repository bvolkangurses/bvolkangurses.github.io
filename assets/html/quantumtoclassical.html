<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quantum to Classical Transition</title>
    <script>
      // Security: Check if accessed from authorized domain
      (function () {
        const allowedDomains = ["volkangurses.com", "bvolkangurses.github.io", "localhost", "127.0.0.1"];

        const currentDomain = window.location.hostname;
        const referrer = document.referrer;

        const isAllowedDomain = allowedDomains.some((domain) => currentDomain.includes(domain));
        const hasValidReferrer = referrer && allowedDomains.some((domain) => referrer.includes(domain));

        if (isAllowedDomain && !hasValidReferrer && !sessionStorage.getItem("auth_sim")) {
          window.location.href = "/software/";
        }

        if (!isAllowedDomain) {
          window.location.href = "/";
        }
      })();
    </script>
    <script>
      // Detect theme from parent page or system preference
      (function () {
        let isDark = false;

        try {
          if (window.parent && window.parent.document) {
            const parentHtml = window.parent.document.documentElement;
            isDark = parentHtml.getAttribute("data-theme") === "dark";
          }
        } catch (e) {
          isDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
        }

        document.documentElement.setAttribute("data-theme", isDark ? "dark" : "light");

        try {
          if (window.parent && window.parent.document) {
            const observer = new MutationObserver(() => {
              const parentHtml = window.parent.document.documentElement;
              const parentTheme = parentHtml.getAttribute("data-theme");
              if (parentTheme) {
                document.documentElement.setAttribute("data-theme", parentTheme);
              }
            });
            observer.observe(window.parent.document.documentElement, {
              attributes: true,
              attributeFilter: ["data-theme"],
            });
          }
        } catch (e) {
          // Silently fail
        }
      })();
    </script>
    <style>
      :root {
        --bg-color: #ffffff;
        --text-color: #000000;
        --text-color-light: #828282;
        --card-bg-color: #f8f9fa;
        --border-color: #dee2e6;
        --button-bg: #b509ac;
        --button-hover: #8a0782;
        --button-text: #ffffff;
        --canvas-border: #dee2e6;
      }

      html[data-theme="dark"] {
        --bg-color: #1c1c1d;
        --text-color: #e0e0e0;
        --text-color-light: #828282;
        --card-bg-color: #212529;
        --border-color: #424246;
        --button-bg: #2698ba;
        --button-hover: #1a7a95;
        --button-text: #ffffff;
        --canvas-border: #424246;
      }

      * {
        transition:
          background-color 0.3s ease,
          color 0.1s ease,
          border-color 0.3s ease;
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 12px 16px 8px 16px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        line-height: 1.5;
      }

      .container {
        max-width: 1000px;
        margin: 0 auto;
      }

      h1 {
        text-align: center;
        font-size: 1.8rem;
        font-weight: 600;
        margin-bottom: 8px;
        color: var(--text-color);
      }

      .subtitle {
        text-align: center;
        font-size: 0.95rem;
        color: var(--text-color-light);
        margin-bottom: 24px;
      }

      .canvas-container {
        display: flex;
        justify-content: center;
        margin-bottom: 16px;
        padding: 12px;
        background-color: var(--card-bg-color);
        border-radius: 8px;
        border: 1px solid var(--border-color);
      }

      canvas {
        border: 2px solid var(--canvas-border);
        border-radius: 6px;
        cursor: crosshair;
        max-width: 100%;
        height: auto;
      }

      .controls {
        display: flex;
        flex-direction: column;
        gap: 14px;
        padding: 16px 20px;
        background-color: var(--card-bg-color);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        margin-bottom: 16px;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .control-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      label {
        font-weight: 500;
        font-size: 0.9rem;
        min-width: 120px;
        color: var(--text-color);
      }

      input[type="range"] {
        flex: 1;
        height: 6px;
        border-radius: 3px;
        background: var(--border-color);
        outline: none;
        -webkit-appearance: none;
        appearance: none;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--button-bg);
        cursor: pointer;
      }

      input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--button-bg);
        cursor: pointer;
        border: none;
      }

      .value-display {
        min-width: 70px;
        text-align: right;
        font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas, "Courier New", monospace;
        font-size: 0.85rem;
        color: var(--text-color);
      }

      .button-group {
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
      }

      button {
        padding: 8px 20px;
        font-size: 0.9rem;
        font-weight: 500;
        border: none;
        border-radius: 6px;
        background-color: var(--button-bg);
        color: var(--button-text);
        cursor: pointer;
        transition: background-color 0.2s ease;
      }

      button:hover {
        background-color: var(--button-hover);
      }

      button:active {
        transform: scale(0.98);
      }

      .info-box {
        padding: 16px 20px;
        background-color: var(--card-bg-color);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        margin-bottom: 12px;
      }

      .info-box h3 {
        margin-bottom: 10px;
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-color);
      }

      .info-box p {
        margin-bottom: 8px;
        font-size: 0.9rem;
        color: var(--text-color);
      }

      .info-box p:last-child {
        margin-bottom: 0;
      }

      .stats {
        display: flex;
        gap: 20px;
        justify-content: center;
        padding: 12px 16px;
        background-color: var(--card-bg-color);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        margin-bottom: 16px;
      }

      .stat-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 3px;
      }

      .stat-label {
        font-size: 0.8rem;
        color: var(--text-color-light);
      }

      .stat-value {
        font-size: 1.1rem;
        font-weight: 600;
        font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas, "Courier New", monospace;
        color: var(--button-bg);
      }

      @media (max-width: 768px) {
        body {
          padding: 8px;
        }

        h1 {
          font-size: 1.4rem;
        }

        .control-row {
          flex-direction: column;
          align-items: stretch;
        }

        label {
          min-width: auto;
        }

        .value-display {
          text-align: left;
        }

        .stats {
          flex-direction: column;
          gap: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="canvas-container">
        <canvas id="simulationCanvas"></canvas>
      </div>

      <div class="controls">
        <div class="control-group">
          <div class="control-row">
            <label for="hbarSlider">h:</label>
            <input type="range" id="hbarSlider" min="0.01" max="1.0" step="0.01" value="1.0" />
            <span class="value-display" id="hbarValue">1.00</span>
          </div>
        </div>

        <div class="control-group">
          <div class="control-row">
            <label for="speedSlider">Time Speed:</label>
            <input type="range" id="speedSlider" min="0.1" max="2.0" step="0.1" value="1.0" />
            <span class="value-display" id="speedValue">1.0x</span>
          </div>
        </div>

        <div class="button-group">
          <button id="playPauseBtn">Pause</button>
          <button id="clearBtn">Clear Sources</button>
          <button id="animateHbarBtn">Animate h â†’ 0</button>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("simulationCanvas");
      const ctx = canvas.getContext("2d");

      // Set canvas size based on viewport
      canvas.width = Math.min(800, window.innerWidth - 60);
      canvas.height = Math.min(600, window.innerHeight * 0.65);

      const width = canvas.width;
      const height = canvas.height;

      // Physics constants
      const c = 1.0; // speed of light (normalized)
      let hbar = 1.0;
      let timeSpeed = 1.0;
      let time = 0;
      let isPlaying = true;
      let animatingHbar = false;

      // Wave sources
      const sources = [];

      // Track max intensity with adaptive scaling to prevent flashing
      let targetMaxIntensity = 1.0;
      let currentMaxIntensity = 1.0;

      // UI elements
      const hbarSlider = document.getElementById("hbarSlider");
      const hbarValue = document.getElementById("hbarValue");
      const speedSlider = document.getElementById("speedSlider");
      const speedValue = document.getElementById("speedValue");
      const playPauseBtn = document.getElementById("playPauseBtn");
      const clearBtn = document.getElementById("clearBtn");
      const animateHbarBtn = document.getElementById("animateHbarBtn");

      // Function to update hbar
      function updateHbar(value, stopAnimation = true) {
        hbar = parseFloat(value);
        const displayValue = hbar.toFixed(2);
        hbarValue.textContent = displayValue;
        hbarSlider.value = hbar;
        if (stopAnimation) {
          animatingHbar = false;
        }
      }

      // Event listeners
      hbarSlider.addEventListener("input", (e) => {
        updateHbar(e.target.value, true);
      });

      speedSlider.addEventListener("input", (e) => {
        timeSpeed = parseFloat(e.target.value);
        speedValue.textContent = timeSpeed.toFixed(1) + "x";
      });

      playPauseBtn.addEventListener("click", () => {
        isPlaying = !isPlaying;
        playPauseBtn.textContent = isPlaying ? "Pause" : "Play";
      });

      clearBtn.addEventListener("click", () => {
        sources.length = 0;
        time = 0;
        initializeDefaultSource();
      });

      animateHbarBtn.addEventListener("click", () => {
        animatingHbar = true;
        if (!isPlaying) {
          isPlaying = true;
          playPauseBtn.textContent = "Pause";
        }
      });

      // Add source on click
      canvas.addEventListener("click", (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * width;
        const y = ((e.clientY - rect.top) / rect.height) * height;

        // Fixed wavelength for all sources
        const wavelength = 50;
        const k = (2 * Math.PI) / wavelength;
        const omega = 2.0; // Fast angular frequency
        const phase = Math.random() * 2 * Math.PI;

        sources.push({
          x: x,
          y: y,
          k: k,
          omega: omega,
          wavelength: wavelength,
          phase: phase,
        });
      });

      // Compute field at point (x, y) from all sources (dipole radiation)
      function computeField(x, y) {
        if (sources.length === 0) return 0;

        let field = 0;
        let incoherentIntensity = 0;

        for (const source of sources) {
          const dx = x - source.x;
          const dy = y - source.y;
          const r = Math.sqrt(dx * dx + dy * dy);

          if (r < 3) continue; // Skip near source

          // Dipole radiation: amplitude falls off as 1/r
          // Phase: k*r - omega*t (outgoing wave)
          const phase = source.k * r - source.omega * time + source.phase;

          // Quantum coherence length scales with hbar
          // When hbar -> 0, coherence length -> 0, interference disappears
          const coherenceLength = hbar * 200; // Much stronger hbar dependence
          const coherence = Math.exp(-r / (coherenceLength + 1));

          // Wave amplitude with dipole 1/r falloff
          const baseAmplitude = 100 / (r + 5);

          // Coherent part (creates interference)
          field += coherence * baseAmplitude * Math.cos(phase);

          // Incoherent part (classical, no interference)
          incoherentIntensity += (1 - coherence) * baseAmplitude * baseAmplitude;
        }

        // Total intensity = coherent field squared + incoherent intensity
        return field * field + incoherentIntensity;
      }

      // Color mapping function (magma colormap style)
      function intensityToColor(intensity, maxIntensity) {
        // Normalize with higher ceiling for better contrast
        const normalized = Math.min(intensity / maxIntensity, 1);
        const t = Math.pow(normalized, 0.5); // Gamma correction

        // Magma colormap: black -> purple -> red -> orange -> yellow -> white
        let r, g, b;

        if (t < 0.2) {
          // Black to deep purple
          const s = t / 0.2;
          r = Math.floor(25 * s);
          g = Math.floor(10 * s);
          b = Math.floor(50 * s);
        } else if (t < 0.4) {
          // Deep purple to purple-red
          const s = (t - 0.2) / 0.2;
          r = Math.floor(15 + 100 * s);
          g = Math.floor(5 + 15 * s);
          b = Math.floor(40 + 80 * s);
        } else if (t < 0.6) {
          // Purple-red to red-orange
          const s = (t - 0.4) / 0.2;
          r = Math.floor(115 + 100 * s);
          g = Math.floor(20 + 60 * s);
          b = Math.floor(120 - 80 * s);
        } else if (t < 0.8) {
          // Red-orange to orange-yellow
          const s = (t - 0.6) / 0.2;
          r = Math.floor(215 + 30 * s);
          g = Math.floor(80 + 120 * s);
          b = Math.floor(40 - 20 * s);
        } else {
          // Orange-yellow to bright yellow-white
          const s = (t - 0.8) / 0.2;
          r = Math.floor(245 + 10 * s);
          g = Math.floor(200 + 50 * s);
          b = Math.floor(20 + 130 * s);
        }

        return `rgb(${r}, ${g}, ${b})`;
      }

      // Draw function
      function draw() {
        // Get theme colors
        const isDark = document.documentElement.getAttribute("data-theme") === "dark";
        const bgColor = isDark ? "#1c1c1d" : "#ffffff";

        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, width, height);

        if (sources.length === 0) {
          // Draw instruction text
          ctx.fillStyle = isDark ? "#828282" : "#666666";
          ctx.font = "18px -apple-system, BlinkMacSystemFont, sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("Click anywhere to add wave sources", width / 2, height / 2);
          return;
        }

        // Compute field for all pixels (with downsampling for performance)
        const step = 3;
        const intensities = [];

        for (let py = 0; py < height; py += step) {
          for (let px = 0; px < width; px += step) {
            const intensity = computeField(px, py);
            intensities.push({ x: px, y: py, intensity });
          }
        }

        // Use percentile-based scaling for more robust normalization
        const sortedIntensities = intensities.map((p) => p.intensity).sort((a, b) => a - b);
        const percentileIndex = Math.floor(sortedIntensities.length * 0.98); // 98th percentile
        const percentileValue = sortedIntensities[percentileIndex] || 1;

        // Smooth the scaling factor over time
        targetMaxIntensity = Math.max(percentileValue, targetMaxIntensity);
        currentMaxIntensity = currentMaxIntensity * 0.9 + targetMaxIntensity * 0.1;

        // Draw intensity field
        for (const point of intensities) {
          const color = intensityToColor(point.intensity, currentMaxIntensity);
          ctx.fillStyle = color;
          ctx.fillRect(point.x, point.y, step, step);
        }
      }

      // Animation loop
      function animate() {
        if (isPlaying) {
          time += 0.15 * timeSpeed; // Fast time increment for visible waves

          // Animate hbar if requested
          if (animatingHbar && hbar > 0.01) {
            hbar = Math.max(0.01, hbar - 0.003);
            updateHbar(hbar, false);
          } else if (animatingHbar && hbar <= 0.01) {
            animatingHbar = false;
          }
        }

        draw();
        requestAnimationFrame(animate);
      }

      // Initialize with a single source in the center
      function initializeDefaultSource() {
        const wavelength = 50;
        const k = (2 * Math.PI) / wavelength;
        const omega = 2.0;
        const phase = 0;

        sources.push({
          x: width / 2,
          y: height / 2,
          k: k,
          omega: omega,
          wavelength: wavelength,
          phase: phase,
        });
      }

      // Start animation
      initializeDefaultSource();
      draw();
      animate();
    </script>
  </body>
</html>
